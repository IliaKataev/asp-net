@page "/tasks"
@inject IJSRuntime JS

<div class="tasks-header-add">
    <h3 class="tasks-header">Список задач</h3>

    <a class="btn btn-primary" href="/add-task">Добавить задачу</a>
</div>

<div class="sort-panel">
    <div class="sorting">
        <label for="sortOption">Сортировка:</label>
        <select id="sortOption" @onchange="OnSortChanged">
            <option value="default">По умолчанию</option>
            <option value="priority">По важности</option>
            <option value="date">По дате</option>
            <option value="title">По алфавиту</option>
        </select>
    </div>


    <button class="btn-primary" @onclick="InvertSortOrder">Инверсия</button>
</div>



@if(tasks.Count == 0)
{
    <p>Нет задач</p>
}
else
{
    <ul class="p-3 task-list">
        @foreach (var task in tasks)
        {
            <li class="task-item" style="color:@GetPriorityColor(task.Priority);">
                <div class="main-text">
                    <div>
                        <span style="text-decoration:@(task.IsCompleted ? "line-through" : "none")"><strong>@task.Title</strong> -  @task.DueDate.ToShortDateString()</span>
                    </div>
                    <InputCheckbox @bind-Value="task.IsCompleted" @onchange="() => SaveTasksAsync()" />
                </div>
               <div class="main-buttons">
                    <a class="btn btn-secondary button-task-list" href="/task/@task.Id">Подробнее</a>
                    <a class="btn btn-secondary button-task-list" href="/edit-task/@task.Id">Редактировать</a>
                    <button class="btn btn-secondary button-task-list" @onclick="() => DeleteTask(task.Id)">Удалить</button>
               </div>                
            </li>
        }
    </ul>
}


@code {
    public static List<TaskModel> tasks = new();

    [Inject] private HttpClient Http { get; set; }

    protected override async Task OnInitializedAsync()
    {
        var localData = await JS.InvokeAsync<string>("localStorage.getItem", "tasks");

        if (!string.IsNullOrEmpty(localData) && localData != "[]")
        {
            tasks = System.Text.Json.JsonSerializer.Deserialize<List<TaskModel>>(localData);
        }
        else
        {
            var json = await Http.GetStringAsync("sample-data/tasks.json");
            tasks = System.Text.Json.JsonSerializer.Deserialize<List<TaskModel>>(json);

            await SaveTasksAsync();
        }

        ApplySorting();
    }

    public async Task SaveTasksAsync()
    {
        var json = System.Text.Json.JsonSerializer.Serialize(tasks);
        await JS.InvokeVoidAsync("localStorage.setItem", "tasks", json);
    }

    private async Task DeleteTask(Guid id)
    {
        var taskToDelete = tasks.FirstOrDefault(t => t.Id == id);
        if(taskToDelete != null)
        {
            tasks.Remove(taskToDelete);
            await SaveTasksAsync();
        }
    }


    private string GetPriorityColor(TaskPriority priority)
    {
        return priority switch
        {
            TaskPriority.Low => "green",
            TaskPriority.Medium => "goldenrod",
            TaskPriority.High => "red",
            _ => "black"
        };
    }

    //-------------------------------------------------------------

    private string currentSort = "default";
    private bool isSortReversed = false;

    private void OnSortChanged(ChangeEventArgs e)
    {
        currentSort = e.Value.ToString();
        ApplySorting();
    }

    private void InvertSortOrder()
    {
        isSortReversed = !isSortReversed;
        ApplySorting();
    }

    private void ApplySorting()
    {
        switch (currentSort)
        {
            case "priority":
                tasks = tasks.OrderBy(t => t.Priority).ToList();
                break;
            case "date":
                tasks = tasks.OrderBy(t => t.DueDate).ToList();
                break;
            case "title":
                tasks = tasks.OrderBy(t => t.Title).ToList();
                break;
            default:
                break;
        }

        if (isSortReversed)
        {
            tasks.Reverse();
        }
    }

}
